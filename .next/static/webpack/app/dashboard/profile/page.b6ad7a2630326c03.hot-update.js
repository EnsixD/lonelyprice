"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/profile/page",{

/***/ "(app-pages-browser)/./components/animated-background.tsx":
/*!********************************************!*\
  !*** ./components/animated-background.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _AnimatedBackground_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnimatedBackground.css */ \"(app-pages-browser)/./components/AnimatedBackground.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nconst AnimatedBackground = ()=>{\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const timeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Устанавливаем размер canvas\n        const resizeCanvas = ()=>{\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n        };\n        resizeCanvas();\n        let particles = [];\n        const mouse = {\n            x: null,\n            y: null,\n            radius: 180\n        };\n        timeRef.current = 0;\n        // Центральные координаты для эффектов\n        const centerX = canvas.width / 2;\n        const centerY = canvas.height / 2;\n        // Класс частицы\n        class Particle {\n            update(canvas, time, mouse) {\n                if (this.isEnergyParticle) {\n                    // Орбитальное движение с пульсацией\n                    this.orbitAngle += this.orbitSpeed;\n                    this.pulse += this.pulseSpeed;\n                    const pulseEffect = Math.sin(this.pulse) * 0.3 + 1;\n                    const currentOrbitRadius = this.orbitRadius * pulseEffect;\n                    this.x = centerX + Math.cos(this.orbitAngle + time * 0.001) * currentOrbitRadius;\n                    this.y = centerY + Math.sin(this.orbitAngle + time * 0.001) * currentOrbitRadius;\n                    // Пульсация альфы\n                    this.alpha = 0.3 + Math.sin(this.pulse * 2) * 0.2;\n                } else {\n                    // Движение с волновым эффектом\n                    const waveX = Math.sin(time * this.waveSpeed + this.waveOffset) * 0.5;\n                    const waveY = Math.cos(time * this.waveSpeed + this.waveOffset) * 0.5;\n                    this.x += this.speedX + waveX;\n                    this.y += this.speedY + waveY;\n                    // Отскок от границ с замедлением\n                    if (this.x > canvas.width + 20 || this.x < -20) this.speedX = -this.speedX * 0.9;\n                    if (this.y > canvas.height + 20 || this.y < -20) this.speedY = -this.speedY * 0.9;\n                    // Притяжение к центру\n                    const dx = centerX - this.x;\n                    const dy = centerY - this.y;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    const attractionRadius = 500;\n                    if (distance < attractionRadius && distance > 50) {\n                        const force = (attractionRadius - distance) / attractionRadius * 0.001;\n                        this.speedX += dx * force;\n                        this.speedY += dy * force;\n                    }\n                    // Взаимодействие с мышью\n                    if (mouse.x !== null && mouse.y !== null) {\n                        const mx = mouse.x - this.x;\n                        const my = mouse.y - this.y;\n                        const mouseDistance = Math.sqrt(mx * mx + my * my);\n                        if (mouseDistance < mouse.radius) {\n                            const force = (mouse.radius - mouseDistance) / mouse.radius * 0.08;\n                            this.x -= mx * force;\n                            this.y -= my * force;\n                            this.alpha = Math.min(1, this.alpha + 0.1);\n                        }\n                    }\n                    // Медленная пульсация альфы\n                    this.pulse += this.pulseSpeed;\n                    this.alpha = 0.3 + Math.sin(this.pulse) * 0.2;\n                }\n                // Ограничение скорости\n                const speed = Math.sqrt(this.speedX * this.speedX + this.speedY * this.speedY);\n                const maxSpeed = this.isEnergyParticle ? 0.5 : 1.5;\n                if (speed > maxSpeed) {\n                    this.speedX = this.speedX / speed * maxSpeed;\n                    this.speedY = this.speedY / speed * maxSpeed;\n                }\n            }\n            draw(ctx) {\n                ctx.globalAlpha = this.alpha;\n                if (this.isEnergyParticle) {\n                    // Энергетические частицы со свечением\n                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 3);\n                    gradient.addColorStop(0, \"rgba(255, 255, 255, 0.9)\");\n                    gradient.addColorStop(1, \"rgba(255, 255, 255, 0)\");\n                    ctx.fillStyle = gradient;\n                    ctx.beginPath();\n                    ctx.arc(this.x, this.y, this.size * 3, 0, Math.PI * 2);\n                    ctx.fill();\n                    // Ядро частицы\n                    ctx.fillStyle = \"#ffffff\";\n                    ctx.beginPath();\n                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n                    ctx.fill();\n                } else {\n                    // Обычные частицы\n                    ctx.fillStyle = this.color;\n                    ctx.beginPath();\n                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n                    ctx.fill();\n                    // Легкое свечение для черных частиц\n                    if (this.color === \"#000000\") {\n                        ctx.shadowColor = \"rgba(255, 255, 255, 0.3)\";\n                        ctx.shadowBlur = 5;\n                        ctx.fill();\n                        ctx.shadowBlur = 0;\n                    }\n                }\n                ctx.globalAlpha = 1;\n            }\n            constructor(canvas){\n                this.isEnergyParticle = Math.random() > 0.8;\n                if (this.isEnergyParticle) {\n                    // Энергетические частицы вращаются по орбите\n                    this.orbitRadius = 100 + Math.random() * 250;\n                    this.orbitAngle = Math.random() * Math.PI * 2;\n                    this.orbitSpeed = (Math.random() - 0.5) * 0.002;\n                    this.x = centerX + Math.cos(this.orbitAngle) * this.orbitRadius;\n                    this.y = centerY + Math.sin(this.orbitAngle) * this.orbitRadius;\n                    this.speedX = 0;\n                    this.speedY = 0;\n                    this.size = Math.random() * 4 + 2;\n                    this.color = \"#ffffff\";\n                    this.alpha = Math.random() * 0.4 + 0.2;\n                } else {\n                    // Обычные частицы\n                    this.x = Math.random() * canvas.width;\n                    this.y = Math.random() * canvas.height;\n                    this.speedX = (Math.random() - 0.5) * 0.8;\n                    this.speedY = (Math.random() - 0.5) * 0.8;\n                    this.size = Math.random() * 2.5 + 0.5;\n                    this.color = Math.random() > 0.5 ? \"#000000\" : \"#111111\";\n                    this.alpha = Math.random() * 0.6 + 0.3;\n                    this.orbitRadius = 0;\n                    this.orbitAngle = 0;\n                    this.orbitSpeed = 0;\n                }\n                this.waveOffset = Math.random() * Math.PI * 2;\n                this.waveSpeed = Math.random() * 0.02 + 0.01;\n                this.pulse = Math.random() * Math.PI * 2;\n                this.pulseSpeed = Math.random() * 0.03 + 0.01;\n            }\n        }\n        const initParticles = ()=>{\n            particles = [];\n            const particleCount = Math.min(350, canvas.width * canvas.height / 1200);\n            for(let i = 0; i < particleCount; i++){\n                particles.push(new Particle(canvas));\n            }\n        };\n        const drawDynamicGradient = (time)=>{\n            // Анимированный градиент\n            const pulse = Math.sin(time * 0.001) * 0.1 + 0.9;\n            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(canvas.width, canvas.height) * 0.8 * pulse);\n            gradient.addColorStop(0, \"rgba(0, 0, 0, 0.95)\");\n            gradient.addColorStop(0.3, \"rgba(10, 10, 10, 0.85)\");\n            gradient.addColorStop(0.6, \"rgba(20, 20, 20, 0.7)\");\n            gradient.addColorStop(1, \"rgba(30, 30, 30, 0.6)\");\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        };\n        const drawNexus = (time)=>{\n            // Центральный энергетический узел\n            const pulse = Math.sin(time * 0.002) * 0.2 + 0.8;\n            const rotation = time * 0.0005;\n            ctx.save();\n            ctx.translate(centerX, centerY);\n            ctx.rotate(rotation);\n            // Внутреннее ядро\n            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 80 * pulse);\n            coreGradient.addColorStop(0, \"rgba(255, 255, 255, 0.2)\");\n            coreGradient.addColorStop(1, \"rgba(255, 255, 255, 0)\");\n            ctx.beginPath();\n            ctx.arc(0, 0, 80 * pulse, 0, Math.PI * 2);\n            ctx.fillStyle = coreGradient;\n            ctx.fill();\n            // Концентрические кольца\n            for(let i = 1; i <= 4; i++){\n                const ringRadius = 100 + i * 40;\n                const ringAlpha = 0.1 - i * 0.02;\n                const ringPulse = Math.sin(time * 0.001 + i * 0.5) * 0.05;\n                ctx.beginPath();\n                ctx.arc(0, 0, ringRadius * (1 + ringPulse), 0, Math.PI * 2);\n                ctx.strokeStyle = \"rgba(255, 255, 255, \".concat(ringAlpha, \")\");\n                ctx.lineWidth = 1 + i * 0.5;\n                ctx.stroke();\n            }\n            // Лучи энергии\n            for(let i = 0; i < 8; i++){\n                const angle = i / 8 * Math.PI * 2 + rotation * 2;\n                const length = 150 + Math.sin(time * 0.003 + i) * 30;\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.lineTo(Math.cos(angle) * length, Math.sin(angle) * length);\n                ctx.strokeStyle = \"rgba(255, 255, 255, \".concat(0.1 + Math.sin(time * 0.002 + i) * 0.05, \")\");\n                ctx.lineWidth = 2;\n                ctx.stroke();\n            }\n            ctx.restore();\n        };\n        const connectParticles = (time)=>{\n            const maxDistance = 150;\n            for(let i = 0; i < particles.length; i++){\n                // Соединение с центральным узлом\n                const dxToCenter = particles[i].x - centerX;\n                const dyToCenter = particles[i].y - centerY;\n                const distanceToCenter = Math.sqrt(dxToCenter * dxToCenter + dyToCenter * dyToCenter);\n                if (distanceToCenter < 400 && particles[i].isEnergyParticle) {\n                    const opacity = 1 - distanceToCenter / 400;\n                    ctx.strokeStyle = \"rgba(255, 255, 255, \".concat(opacity * 0.1, \")\");\n                    ctx.lineWidth = 0.5 + opacity * 0.5;\n                    ctx.beginPath();\n                    ctx.moveTo(particles[i].x, particles[i].y);\n                    ctx.lineTo(centerX, centerY);\n                    ctx.stroke();\n                }\n                // Соединение между частицами\n                for(let j = i + 1; j < particles.length; j++){\n                    const dx = particles[i].x - particles[j].x;\n                    const dy = particles[i].y - particles[j].y;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    if (distance < maxDistance) {\n                        const opacity = 1 - distance / maxDistance;\n                        const isEnergyConnection = particles[i].isEnergyParticle && particles[j].isEnergyParticle;\n                        ctx.strokeStyle = isEnergyConnection ? \"rgba(255, 255, 255, \".concat(opacity * 0.2, \")\") : \"rgba(0, 0, 0, \".concat(opacity * 0.15, \")\");\n                        ctx.lineWidth = isEnergyConnection ? 1 : 0.5;\n                        ctx.beginPath();\n                        ctx.moveTo(particles[i].x, particles[i].y);\n                        ctx.lineTo(particles[j].x, particles[j].y);\n                        ctx.stroke();\n                    }\n                }\n            }\n        };\n        const drawGrid = (time)=>{\n            const gridSize = 80;\n            const gridOffset = time * 0.05;\n            ctx.strokeStyle = \"rgba(255, 255, 255, 0.03)\";\n            ctx.lineWidth = 0.5;\n            // Вертикальные линии с параллаксом\n            for(let x = -gridSize; x < canvas.width + gridSize; x += gridSize){\n                const offsetX = (x + gridOffset) % gridSize;\n                ctx.beginPath();\n                ctx.moveTo(offsetX, 0);\n                ctx.lineTo(offsetX, canvas.height);\n                ctx.stroke();\n            }\n            // Горизонтальные линии с параллаксом\n            for(let y = -gridSize; y < canvas.height + gridSize; y += gridSize){\n                const offsetY = (y + gridOffset * 0.7) % gridSize;\n                ctx.beginPath();\n                ctx.moveTo(0, offsetY);\n                ctx.lineTo(canvas.width, offsetY);\n                ctx.stroke();\n            }\n        };\n        const animate = (time)=>{\n            timeRef.current = time;\n            // Очистка с прозрачностью для эффекта шлейфа\n            ctx.fillStyle = \"rgba(5, 5, 5, 0.05)\";\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Рисуем фон\n            drawDynamicGradient(time);\n            // Рисуем сетку\n            drawGrid(time);\n            // Рисуем центральный узел\n            drawNexus(time);\n            // Обновляем и рисуем частицы\n            particles.forEach((particle)=>{\n                particle.update(canvas, time, mouse);\n                particle.draw(ctx);\n            });\n            // Соединяем частицы\n            connectParticles(time);\n            animationRef.current = requestAnimationFrame(animate);\n        };\n        // Обработчики событий\n        const handleMouseMove = (e)=>{\n            mouse.x = e.clientX;\n            mouse.y = e.clientY;\n        };\n        const handleMouseLeave = ()=>{\n            mouse.x = null;\n            mouse.y = null;\n        };\n        // Инициализация\n        initParticles();\n        animationRef.current = requestAnimationFrame(animate);\n        // Слушатели событий\n        window.addEventListener(\"resize\", resizeCanvas);\n        window.addEventListener(\"mousemove\", handleMouseMove);\n        window.addEventListener(\"mouseleave\", handleMouseLeave);\n        // Очистка\n        return ()=>{\n            cancelAnimationFrame(animationRef.current);\n            window.removeEventListener(\"resize\", resizeCanvas);\n            window.removeEventListener(\"mousemove\", handleMouseMove);\n            window.removeEventListener(\"mouseleave\", handleMouseLeave);\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"animated-background-canvas\",\n        style: {\n            position: \"fixed\",\n            top: 0,\n            left: 0,\n            width: \"100%\",\n            height: \"100%\",\n            zIndex: -10,\n            pointerEvents: \"none\",\n            opacity: 1\n        }\n    }, void 0, false, {\n        fileName: \"/home/ensi/Projects/lonlyprice/components/animated-background.tsx\",\n        lineNumber: 450,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AnimatedBackground, \"Ojp6hAaDINgKT/jIQnP//OQkN58=\");\n_c = AnimatedBackground;\n/* harmony default export */ __webpack_exports__[\"default\"] = (AnimatedBackground);\nvar _c;\n$RefreshReg$(_c, \"AnimatedBackground\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvYW5pbWF0ZWQtYmFja2dyb3VuZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVpRDtBQUNmO0FBcUJsQyxNQUFNRyxxQkFBcUI7O0lBQ3pCLE1BQU1DLFlBQVlGLDZDQUFNQSxDQUFvQjtJQUM1QyxNQUFNRyxlQUFlSCw2Q0FBTUEsQ0FBUztJQUNwQyxNQUFNSSxVQUFVSiw2Q0FBTUEsQ0FBUztJQUUvQkQsZ0RBQVNBLENBQUM7UUFDUixNQUFNTSxTQUFTSCxVQUFVSSxPQUFPO1FBQ2hDLElBQUksQ0FBQ0QsUUFBUTtRQUViLE1BQU1FLE1BQU1GLE9BQU9HLFVBQVUsQ0FBQztRQUM5QixJQUFJLENBQUNELEtBQUs7UUFFViw4QkFBOEI7UUFDOUIsTUFBTUUsZUFBZTtZQUNuQkosT0FBT0ssS0FBSyxHQUFHQyxPQUFPQyxVQUFVO1lBQ2hDUCxPQUFPUSxNQUFNLEdBQUdGLE9BQU9HLFdBQVc7UUFDcEM7UUFFQUw7UUFFQSxJQUFJTSxZQUE0QixFQUFFO1FBQ2xDLE1BQU1DLFFBQVE7WUFDWkMsR0FBRztZQUNIQyxHQUFHO1lBQ0hDLFFBQVE7UUFDVjtRQUNBZixRQUFRRSxPQUFPLEdBQUc7UUFFbEIsc0NBQXNDO1FBQ3RDLE1BQU1jLFVBQVVmLE9BQU9LLEtBQUssR0FBRztRQUMvQixNQUFNVyxVQUFVaEIsT0FBT1EsTUFBTSxHQUFHO1FBRWhDLGdCQUFnQjtRQUNoQixNQUFNUztZQW9ESkMsT0FDRWxCLE1BQXlCLEVBQ3pCbUIsSUFBWSxFQUNaUixLQUE2RCxFQUM3RDtnQkFDQSxJQUFJLElBQUksQ0FBQ1MsZ0JBQWdCLEVBQUU7b0JBQ3pCLG9DQUFvQztvQkFDcEMsSUFBSSxDQUFDQyxVQUFVLElBQUksSUFBSSxDQUFDQyxVQUFVO29CQUNsQyxJQUFJLENBQUNDLEtBQUssSUFBSSxJQUFJLENBQUNDLFVBQVU7b0JBRTdCLE1BQU1DLGNBQWNDLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNKLEtBQUss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QXhiTW5HO0tBQUFBO0FBMGJOLCtEQUFlQSxrQkFBa0JBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9hbmltYXRlZC1iYWNrZ3JvdW5kLnRzeD8zZDQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBcIi4vQW5pbWF0ZWRCYWNrZ3JvdW5kLmNzc1wiO1xuXG5pbnRlcmZhY2UgUGFydGljbGVUeXBlIHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIHNpemU6IG51bWJlcjtcbiAgc3BlZWRYOiBudW1iZXI7XG4gIHNwZWVkWTogbnVtYmVyO1xuICBjb2xvcjogc3RyaW5nO1xuICBhbHBoYTogbnVtYmVyO1xuICB3YXZlT2Zmc2V0OiBudW1iZXI7XG4gIHdhdmVTcGVlZDogbnVtYmVyO1xuICBpc0VuZXJneVBhcnRpY2xlOiBib29sZWFuO1xuICB1cGRhdGU6IChcbiAgICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICAgIHRpbWU6IG51bWJlcixcbiAgICBtb3VzZTogeyB4OiBudW1iZXIgfCBudWxsOyB5OiBudW1iZXIgfCBudWxsOyByYWRpdXM6IG51bWJlciB9XG4gICkgPT4gdm9pZDtcbiAgZHJhdzogKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSA9PiB2b2lkO1xufVxuXG5jb25zdCBBbmltYXRlZEJhY2tncm91bmQgPSAoKSA9PiB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IGFuaW1hdGlvblJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xuICBjb25zdCB0aW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xuXG4gICAgLy8g0KPRgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0YDQsNC30LzQtdGAIGNhbnZhc1xuICAgIGNvbnN0IHJlc2l6ZUNhbnZhcyA9ICgpID0+IHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9O1xuXG4gICAgcmVzaXplQ2FudmFzKCk7XG5cbiAgICBsZXQgcGFydGljbGVzOiBQYXJ0aWNsZVR5cGVbXSA9IFtdO1xuICAgIGNvbnN0IG1vdXNlID0ge1xuICAgICAgeDogbnVsbCBhcyBudW1iZXIgfCBudWxsLFxuICAgICAgeTogbnVsbCBhcyBudW1iZXIgfCBudWxsLFxuICAgICAgcmFkaXVzOiAxODAsXG4gICAgfTtcbiAgICB0aW1lUmVmLmN1cnJlbnQgPSAwO1xuXG4gICAgLy8g0KbQtdC90YLRgNCw0LvRjNC90YvQtSDQutC+0L7RgNC00LjQvdCw0YLRiyDQtNC70Y8g0Y3RhNGE0LXQutGC0L7QslxuICAgIGNvbnN0IGNlbnRlclggPSBjYW52YXMud2lkdGggLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBjYW52YXMuaGVpZ2h0IC8gMjtcblxuICAgIC8vINCa0LvQsNGB0YEg0YfQsNGB0YLQuNGG0YtcbiAgICBjbGFzcyBQYXJ0aWNsZSBpbXBsZW1lbnRzIFBhcnRpY2xlVHlwZSB7XG4gICAgICB4OiBudW1iZXI7XG4gICAgICB5OiBudW1iZXI7XG4gICAgICBzaXplOiBudW1iZXI7XG4gICAgICBzcGVlZFg6IG51bWJlcjtcbiAgICAgIHNwZWVkWTogbnVtYmVyO1xuICAgICAgY29sb3I6IHN0cmluZztcbiAgICAgIGFscGhhOiBudW1iZXI7XG4gICAgICB3YXZlT2Zmc2V0OiBudW1iZXI7XG4gICAgICB3YXZlU3BlZWQ6IG51bWJlcjtcbiAgICAgIGlzRW5lcmd5UGFydGljbGU6IGJvb2xlYW47XG4gICAgICBvcmJpdFJhZGl1czogbnVtYmVyO1xuICAgICAgb3JiaXRBbmdsZTogbnVtYmVyO1xuICAgICAgb3JiaXRTcGVlZDogbnVtYmVyO1xuICAgICAgcHVsc2U6IG51bWJlcjtcbiAgICAgIHB1bHNlU3BlZWQ6IG51bWJlcjtcblxuICAgICAgY29uc3RydWN0b3IoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICB0aGlzLmlzRW5lcmd5UGFydGljbGUgPSBNYXRoLnJhbmRvbSgpID4gMC44O1xuXG4gICAgICAgIGlmICh0aGlzLmlzRW5lcmd5UGFydGljbGUpIHtcbiAgICAgICAgICAvLyDQrdC90LXRgNCz0LXRgtC40YfQtdGB0LrQuNC1INGH0LDRgdGC0LjRhtGLINCy0YDQsNGJ0LDRjtGC0YHRjyDQv9C+INC+0YDQsdC40YLQtVxuICAgICAgICAgIHRoaXMub3JiaXRSYWRpdXMgPSAxMDAgKyBNYXRoLnJhbmRvbSgpICogMjUwO1xuICAgICAgICAgIHRoaXMub3JiaXRBbmdsZSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcbiAgICAgICAgICB0aGlzLm9yYml0U3BlZWQgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAwMjtcbiAgICAgICAgICB0aGlzLnggPSBjZW50ZXJYICsgTWF0aC5jb3ModGhpcy5vcmJpdEFuZ2xlKSAqIHRoaXMub3JiaXRSYWRpdXM7XG4gICAgICAgICAgdGhpcy55ID0gY2VudGVyWSArIE1hdGguc2luKHRoaXMub3JiaXRBbmdsZSkgKiB0aGlzLm9yYml0UmFkaXVzO1xuICAgICAgICAgIHRoaXMuc3BlZWRYID0gMDtcbiAgICAgICAgICB0aGlzLnNwZWVkWSA9IDA7XG4gICAgICAgICAgdGhpcy5zaXplID0gTWF0aC5yYW5kb20oKSAqIDQgKyAyO1xuICAgICAgICAgIHRoaXMuY29sb3IgPSBcIiNmZmZmZmZcIjtcbiAgICAgICAgICB0aGlzLmFscGhhID0gTWF0aC5yYW5kb20oKSAqIDAuNCArIDAuMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyDQntCx0YvRh9C90YvQtSDRh9Cw0YHRgtC40YbRi1xuICAgICAgICAgIHRoaXMueCA9IE1hdGgucmFuZG9tKCkgKiBjYW52YXMud2lkdGg7XG4gICAgICAgICAgdGhpcy55ID0gTWF0aC5yYW5kb20oKSAqIGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgdGhpcy5zcGVlZFggPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjg7XG4gICAgICAgICAgdGhpcy5zcGVlZFkgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjg7XG4gICAgICAgICAgdGhpcy5zaXplID0gTWF0aC5yYW5kb20oKSAqIDIuNSArIDAuNTtcbiAgICAgICAgICB0aGlzLmNvbG9yID0gTWF0aC5yYW5kb20oKSA+IDAuNSA/IFwiIzAwMDAwMFwiIDogXCIjMTExMTExXCI7XG4gICAgICAgICAgdGhpcy5hbHBoYSA9IE1hdGgucmFuZG9tKCkgKiAwLjYgKyAwLjM7XG4gICAgICAgICAgdGhpcy5vcmJpdFJhZGl1cyA9IDA7XG4gICAgICAgICAgdGhpcy5vcmJpdEFuZ2xlID0gMDtcbiAgICAgICAgICB0aGlzLm9yYml0U3BlZWQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53YXZlT2Zmc2V0ID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuICAgICAgICB0aGlzLndhdmVTcGVlZCA9IE1hdGgucmFuZG9tKCkgKiAwLjAyICsgMC4wMTtcbiAgICAgICAgdGhpcy5wdWxzZSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcbiAgICAgICAgdGhpcy5wdWxzZVNwZWVkID0gTWF0aC5yYW5kb20oKSAqIDAuMDMgKyAwLjAxO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUoXG4gICAgICAgIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXG4gICAgICAgIHRpbWU6IG51bWJlcixcbiAgICAgICAgbW91c2U6IHsgeDogbnVtYmVyIHwgbnVsbDsgeTogbnVtYmVyIHwgbnVsbDsgcmFkaXVzOiBudW1iZXIgfVxuICAgICAgKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5lcmd5UGFydGljbGUpIHtcbiAgICAgICAgICAvLyDQntGA0LHQuNGC0LDQu9GM0L3QvtC1INC00LLQuNC20LXQvdC40LUg0YEg0L/Rg9C70YzRgdCw0YbQuNC10LlcbiAgICAgICAgICB0aGlzLm9yYml0QW5nbGUgKz0gdGhpcy5vcmJpdFNwZWVkO1xuICAgICAgICAgIHRoaXMucHVsc2UgKz0gdGhpcy5wdWxzZVNwZWVkO1xuXG4gICAgICAgICAgY29uc3QgcHVsc2VFZmZlY3QgPSBNYXRoLnNpbih0aGlzLnB1bHNlKSAqIDAuMyArIDE7XG4gICAgICAgICAgY29uc3QgY3VycmVudE9yYml0UmFkaXVzID0gdGhpcy5vcmJpdFJhZGl1cyAqIHB1bHNlRWZmZWN0O1xuXG4gICAgICAgICAgdGhpcy54ID1cbiAgICAgICAgICAgIGNlbnRlclggK1xuICAgICAgICAgICAgTWF0aC5jb3ModGhpcy5vcmJpdEFuZ2xlICsgdGltZSAqIDAuMDAxKSAqIGN1cnJlbnRPcmJpdFJhZGl1cztcbiAgICAgICAgICB0aGlzLnkgPVxuICAgICAgICAgICAgY2VudGVyWSArXG4gICAgICAgICAgICBNYXRoLnNpbih0aGlzLm9yYml0QW5nbGUgKyB0aW1lICogMC4wMDEpICogY3VycmVudE9yYml0UmFkaXVzO1xuXG4gICAgICAgICAgLy8g0J/Rg9C70YzRgdCw0YbQuNGPINCw0LvRjNGE0YtcbiAgICAgICAgICB0aGlzLmFscGhhID0gMC4zICsgTWF0aC5zaW4odGhpcy5wdWxzZSAqIDIpICogMC4yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vINCU0LLQuNC20LXQvdC40LUg0YEg0LLQvtC70L3QvtCy0YvQvCDRjdGE0YTQtdC60YLQvtC8XG4gICAgICAgICAgY29uc3Qgd2F2ZVggPSBNYXRoLnNpbih0aW1lICogdGhpcy53YXZlU3BlZWQgKyB0aGlzLndhdmVPZmZzZXQpICogMC41O1xuICAgICAgICAgIGNvbnN0IHdhdmVZID0gTWF0aC5jb3ModGltZSAqIHRoaXMud2F2ZVNwZWVkICsgdGhpcy53YXZlT2Zmc2V0KSAqIDAuNTtcblxuICAgICAgICAgIHRoaXMueCArPSB0aGlzLnNwZWVkWCArIHdhdmVYO1xuICAgICAgICAgIHRoaXMueSArPSB0aGlzLnNwZWVkWSArIHdhdmVZO1xuXG4gICAgICAgICAgLy8g0J7RgtGB0LrQvtC6INC+0YIg0LPRgNCw0L3QuNGGINGBINC30LDQvNC10LTQu9C10L3QuNC10LxcbiAgICAgICAgICBpZiAodGhpcy54ID4gY2FudmFzLndpZHRoICsgMjAgfHwgdGhpcy54IDwgLTIwKVxuICAgICAgICAgICAgdGhpcy5zcGVlZFggPSAtdGhpcy5zcGVlZFggKiAwLjk7XG4gICAgICAgICAgaWYgKHRoaXMueSA+IGNhbnZhcy5oZWlnaHQgKyAyMCB8fCB0aGlzLnkgPCAtMjApXG4gICAgICAgICAgICB0aGlzLnNwZWVkWSA9IC10aGlzLnNwZWVkWSAqIDAuOTtcblxuICAgICAgICAgIC8vINCf0YDQuNGC0Y/QttC10L3QuNC1INC6INGG0LXQvdGC0YDRg1xuICAgICAgICAgIGNvbnN0IGR4ID0gY2VudGVyWCAtIHRoaXMueDtcbiAgICAgICAgICBjb25zdCBkeSA9IGNlbnRlclkgLSB0aGlzLnk7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgIGNvbnN0IGF0dHJhY3Rpb25SYWRpdXMgPSA1MDA7XG5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBhdHRyYWN0aW9uUmFkaXVzICYmIGRpc3RhbmNlID4gNTApIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcmNlID1cbiAgICAgICAgICAgICAgKChhdHRyYWN0aW9uUmFkaXVzIC0gZGlzdGFuY2UpIC8gYXR0cmFjdGlvblJhZGl1cykgKiAwLjAwMTtcbiAgICAgICAgICAgIHRoaXMuc3BlZWRYICs9IGR4ICogZm9yY2U7XG4gICAgICAgICAgICB0aGlzLnNwZWVkWSArPSBkeSAqIGZvcmNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vINCS0LfQsNC40LzQvtC00LXQudGB0YLQstC40LUg0YEg0LzRi9GI0YzRjlxuICAgICAgICAgIGlmIChtb3VzZS54ICE9PSBudWxsICYmIG1vdXNlLnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG14ID0gbW91c2UueCAtIHRoaXMueDtcbiAgICAgICAgICAgIGNvbnN0IG15ID0gbW91c2UueSAtIHRoaXMueTtcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlRGlzdGFuY2UgPSBNYXRoLnNxcnQobXggKiBteCArIG15ICogbXkpO1xuXG4gICAgICAgICAgICBpZiAobW91c2VEaXN0YW5jZSA8IG1vdXNlLnJhZGl1cykge1xuICAgICAgICAgICAgICBjb25zdCBmb3JjZSA9XG4gICAgICAgICAgICAgICAgKChtb3VzZS5yYWRpdXMgLSBtb3VzZURpc3RhbmNlKSAvIG1vdXNlLnJhZGl1cykgKiAwLjA4O1xuICAgICAgICAgICAgICB0aGlzLnggLT0gbXggKiBmb3JjZTtcbiAgICAgICAgICAgICAgdGhpcy55IC09IG15ICogZm9yY2U7XG4gICAgICAgICAgICAgIHRoaXMuYWxwaGEgPSBNYXRoLm1pbigxLCB0aGlzLmFscGhhICsgMC4xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyDQnNC10LTQu9C10L3QvdCw0Y8g0L/Rg9C70YzRgdCw0YbQuNGPINCw0LvRjNGE0YtcbiAgICAgICAgICB0aGlzLnB1bHNlICs9IHRoaXMucHVsc2VTcGVlZDtcbiAgICAgICAgICB0aGlzLmFscGhhID0gMC4zICsgTWF0aC5zaW4odGhpcy5wdWxzZSkgKiAwLjI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQntCz0YDQsNC90LjRh9C10L3QuNC1INGB0LrQvtGA0L7RgdGC0LhcbiAgICAgICAgY29uc3Qgc3BlZWQgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgdGhpcy5zcGVlZFggKiB0aGlzLnNwZWVkWCArIHRoaXMuc3BlZWRZICogdGhpcy5zcGVlZFlcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbWF4U3BlZWQgPSB0aGlzLmlzRW5lcmd5UGFydGljbGUgPyAwLjUgOiAxLjU7XG4gICAgICAgIGlmIChzcGVlZCA+IG1heFNwZWVkKSB7XG4gICAgICAgICAgdGhpcy5zcGVlZFggPSAodGhpcy5zcGVlZFggLyBzcGVlZCkgKiBtYXhTcGVlZDtcbiAgICAgICAgICB0aGlzLnNwZWVkWSA9ICh0aGlzLnNwZWVkWSAvIHNwZWVkKSAqIG1heFNwZWVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5hbHBoYTtcblxuICAgICAgICBpZiAodGhpcy5pc0VuZXJneVBhcnRpY2xlKSB7XG4gICAgICAgICAgLy8g0K3QvdC10YDQs9C10YLQuNGH0LXRgdC60LjQtSDRh9Cw0YHRgtC40YbRiyDRgdC+INGB0LLQtdGH0LXQvdC40LXQvFxuICAgICAgICAgIGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgICAgICAgdGhpcy54LFxuICAgICAgICAgICAgdGhpcy55LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMueCxcbiAgICAgICAgICAgIHRoaXMueSxcbiAgICAgICAgICAgIHRoaXMuc2l6ZSAqIDNcbiAgICAgICAgICApO1xuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC45KVwiKTtcbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDApXCIpO1xuXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHguYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnNpemUgKiAzLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICAgIC8vINCv0LTRgNC+INGH0LDRgdGC0LjRhtGLXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZmZmZmZlwiO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHguYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnNpemUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vINCe0LHRi9GH0L3Ri9C1INGH0LDRgdGC0LjRhtGLXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5hcmModGhpcy54LCB0aGlzLnksIHRoaXMuc2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAvLyDQm9C10LPQutC+0LUg0YHQstC10YfQtdC90LjQtSDQtNC70Y8g0YfQtdGA0L3Ri9GFINGH0LDRgdGC0LjRhlxuICAgICAgICAgIGlmICh0aGlzLmNvbG9yID09PSBcIiMwMDAwMDBcIikge1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMylcIjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gNTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbml0UGFydGljbGVzID0gKCkgPT4ge1xuICAgICAgcGFydGljbGVzID0gW107XG4gICAgICBjb25zdCBwYXJ0aWNsZUNvdW50ID0gTWF0aC5taW4oXG4gICAgICAgIDM1MCxcbiAgICAgICAgKGNhbnZhcy53aWR0aCAqIGNhbnZhcy5oZWlnaHQpIC8gMTIwMFxuICAgICAgKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNsZUNvdW50OyBpKyspIHtcbiAgICAgICAgcGFydGljbGVzLnB1c2gobmV3IFBhcnRpY2xlKGNhbnZhcykpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBkcmF3RHluYW1pY0dyYWRpZW50ID0gKHRpbWU6IG51bWJlcikgPT4ge1xuICAgICAgLy8g0JDQvdC40LzQuNGA0L7QstCw0L3QvdGL0Lkg0LPRgNCw0LTQuNC10L3RglxuICAgICAgY29uc3QgcHVsc2UgPSBNYXRoLnNpbih0aW1lICogMC4wMDEpICogMC4xICsgMC45O1xuXG4gICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgICAgY2VudGVyWCxcbiAgICAgICAgY2VudGVyWSxcbiAgICAgICAgMCxcbiAgICAgICAgY2VudGVyWCxcbiAgICAgICAgY2VudGVyWSxcbiAgICAgICAgTWF0aC5tYXgoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KSAqIDAuOCAqIHB1bHNlXG4gICAgICApO1xuXG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgXCJyZ2JhKDAsIDAsIDAsIDAuOTUpXCIpO1xuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuMywgXCJyZ2JhKDEwLCAxMCwgMTAsIDAuODUpXCIpO1xuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuNiwgXCJyZ2JhKDIwLCAyMCwgMjAsIDAuNylcIik7XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgXCJyZ2JhKDMwLCAzMCwgMzAsIDAuNilcIik7XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIH07XG5cbiAgICBjb25zdCBkcmF3TmV4dXMgPSAodGltZTogbnVtYmVyKSA9PiB7XG4gICAgICAvLyDQptC10L3RgtGA0LDQu9GM0L3Ri9C5INGN0L3QtdGA0LPQtdGC0LjRh9C10YHQutC40Lkg0YPQt9C10LtcbiAgICAgIGNvbnN0IHB1bHNlID0gTWF0aC5zaW4odGltZSAqIDAuMDAyKSAqIDAuMiArIDAuODtcbiAgICAgIGNvbnN0IHJvdGF0aW9uID0gdGltZSAqIDAuMDAwNTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICBjdHgucm90YXRlKHJvdGF0aW9uKTtcblxuICAgICAgLy8g0JLQvdGD0YLRgNC10L3QvdC10LUg0Y/QtNGA0L5cbiAgICAgIGNvbnN0IGNvcmVHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCgwLCAwLCAwLCAwLCAwLCA4MCAqIHB1bHNlKTtcbiAgICAgIGNvcmVHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMilcIik7XG4gICAgICBjb3JlR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwKVwiKTtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYygwLCAwLCA4MCAqIHB1bHNlLCAwLCBNYXRoLlBJICogMik7XG4gICAgICBjdHguZmlsbFN0eWxlID0gY29yZUdyYWRpZW50O1xuICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgLy8g0JrQvtC90YbQtdC90YLRgNC40YfQtdGB0LrQuNC1INC60L7Qu9GM0YbQsFxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJpbmdSYWRpdXMgPSAxMDAgKyBpICogNDA7XG4gICAgICAgIGNvbnN0IHJpbmdBbHBoYSA9IDAuMSAtIGkgKiAwLjAyO1xuICAgICAgICBjb25zdCByaW5nUHVsc2UgPSBNYXRoLnNpbih0aW1lICogMC4wMDEgKyBpICogMC41KSAqIDAuMDU7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKDAsIDAsIHJpbmdSYWRpdXMgKiAoMSArIHJpbmdQdWxzZSksIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYHJnYmEoMjU1LCAyNTUsIDI1NSwgJHtyaW5nQWxwaGF9KWA7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxICsgaSAqIDAuNTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyDQm9GD0YfQuCDRjdC90LXRgNCz0LjQuFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoaSAvIDgpICogTWF0aC5QSSAqIDIgKyByb3RhdGlvbiAqIDI7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IDE1MCArIE1hdGguc2luKHRpbWUgKiAwLjAwMyArIGkpICogMzA7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICBjdHgubGluZVRvKE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCwgTWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYHJnYmEoMjU1LCAyNTUsIDI1NSwgJHtcbiAgICAgICAgICAwLjEgKyBNYXRoLnNpbih0aW1lICogMC4wMDIgKyBpKSAqIDAuMDVcbiAgICAgICAgfSlgO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBjb25uZWN0UGFydGljbGVzID0gKHRpbWU6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgbWF4RGlzdGFuY2UgPSAxNTA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGljbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vINCh0L7QtdC00LjQvdC10L3QuNC1INGBINGG0LXQvdGC0YDQsNC70YzQvdGL0Lwg0YPQt9C70L7QvFxuICAgICAgICBjb25zdCBkeFRvQ2VudGVyID0gcGFydGljbGVzW2ldLnggLSBjZW50ZXJYO1xuICAgICAgICBjb25zdCBkeVRvQ2VudGVyID0gcGFydGljbGVzW2ldLnkgLSBjZW50ZXJZO1xuICAgICAgICBjb25zdCBkaXN0YW5jZVRvQ2VudGVyID0gTWF0aC5zcXJ0KFxuICAgICAgICAgIGR4VG9DZW50ZXIgKiBkeFRvQ2VudGVyICsgZHlUb0NlbnRlciAqIGR5VG9DZW50ZXJcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoZGlzdGFuY2VUb0NlbnRlciA8IDQwMCAmJiBwYXJ0aWNsZXNbaV0uaXNFbmVyZ3lQYXJ0aWNsZSkge1xuICAgICAgICAgIGNvbnN0IG9wYWNpdHkgPSAxIC0gZGlzdGFuY2VUb0NlbnRlciAvIDQwMDtcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBgcmdiYSgyNTUsIDI1NSwgMjU1LCAke29wYWNpdHkgKiAwLjF9KWA7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDAuNSArIG9wYWNpdHkgKiAwLjU7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8ocGFydGljbGVzW2ldLngsIHBhcnRpY2xlc1tpXS55KTtcbiAgICAgICAgICBjdHgubGluZVRvKGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCh0L7QtdC00LjQvdC10L3QuNC1INC80LXQttC00YMg0YfQsNGB0YLQuNGG0LDQvNC4XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHBhcnRpY2xlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGR4ID0gcGFydGljbGVzW2ldLnggLSBwYXJ0aWNsZXNbal0ueDtcbiAgICAgICAgICBjb25zdCBkeSA9IHBhcnRpY2xlc1tpXS55IC0gcGFydGljbGVzW2pdLnk7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wYWNpdHkgPSAxIC0gZGlzdGFuY2UgLyBtYXhEaXN0YW5jZTtcbiAgICAgICAgICAgIGNvbnN0IGlzRW5lcmd5Q29ubmVjdGlvbiA9XG4gICAgICAgICAgICAgIHBhcnRpY2xlc1tpXS5pc0VuZXJneVBhcnRpY2xlICYmIHBhcnRpY2xlc1tqXS5pc0VuZXJneVBhcnRpY2xlO1xuXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBpc0VuZXJneUNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgPyBgcmdiYSgyNTUsIDI1NSwgMjU1LCAke29wYWNpdHkgKiAwLjJ9KWBcbiAgICAgICAgICAgICAgOiBgcmdiYSgwLCAwLCAwLCAke29wYWNpdHkgKiAwLjE1fSlgO1xuXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gaXNFbmVyZ3lDb25uZWN0aW9uID8gMSA6IDAuNTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ocGFydGljbGVzW2ldLngsIHBhcnRpY2xlc1tpXS55KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocGFydGljbGVzW2pdLngsIHBhcnRpY2xlc1tqXS55KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZHJhd0dyaWQgPSAodGltZTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBncmlkU2l6ZSA9IDgwO1xuICAgICAgY29uc3QgZ3JpZE9mZnNldCA9IHRpbWUgKiAwLjA1O1xuXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wMylcIjtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAwLjU7XG5cbiAgICAgIC8vINCS0LXRgNGC0LjQutCw0LvRjNC90YvQtSDQu9C40L3QuNC4INGBINC/0LDRgNCw0LvQu9Cw0LrRgdC+0LxcbiAgICAgIGZvciAobGV0IHggPSAtZ3JpZFNpemU7IHggPCBjYW52YXMud2lkdGggKyBncmlkU2l6ZTsgeCArPSBncmlkU2l6ZSkge1xuICAgICAgICBjb25zdCBvZmZzZXRYID0gKHggKyBncmlkT2Zmc2V0KSAlIGdyaWRTaXplO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ob2Zmc2V0WCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8ob2Zmc2V0WCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8g0JPQvtGA0LjQt9C+0L3RgtCw0LvRjNC90YvQtSDQu9C40L3QuNC4INGBINC/0LDRgNCw0LvQu9Cw0LrRgdC+0LxcbiAgICAgIGZvciAobGV0IHkgPSAtZ3JpZFNpemU7IHkgPCBjYW52YXMuaGVpZ2h0ICsgZ3JpZFNpemU7IHkgKz0gZ3JpZFNpemUpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9ICh5ICsgZ3JpZE9mZnNldCAqIDAuNykgJSBncmlkU2l6ZTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIG9mZnNldFkpO1xuICAgICAgICBjdHgubGluZVRvKGNhbnZhcy53aWR0aCwgb2Zmc2V0WSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYW5pbWF0ZSA9ICh0aW1lOiBudW1iZXIpID0+IHtcbiAgICAgIHRpbWVSZWYuY3VycmVudCA9IHRpbWU7XG5cbiAgICAgIC8vINCe0YfQuNGB0YLQutCwINGBINC/0YDQvtC30YDQsNGH0L3QvtGB0YLRjNGOINC00LvRjyDRjdGE0YTQtdC60YLQsCDRiNC70LXQudGE0LBcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoNSwgNSwgNSwgMC4wNSlcIjtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAvLyDQoNC40YHRg9C10Lwg0YTQvtC9XG4gICAgICBkcmF3RHluYW1pY0dyYWRpZW50KHRpbWUpO1xuXG4gICAgICAvLyDQoNC40YHRg9C10Lwg0YHQtdGC0LrRg1xuICAgICAgZHJhd0dyaWQodGltZSk7XG5cbiAgICAgIC8vINCg0LjRgdGD0LXQvCDRhtC10L3RgtGA0LDQu9GM0L3Ri9C5INGD0LfQtdC7XG4gICAgICBkcmF3TmV4dXModGltZSk7XG5cbiAgICAgIC8vINCe0LHQvdC+0LLQu9GP0LXQvCDQuCDRgNC40YHRg9C10Lwg0YfQsNGB0YLQuNGG0YtcbiAgICAgIHBhcnRpY2xlcy5mb3JFYWNoKChwYXJ0aWNsZSkgPT4ge1xuICAgICAgICBwYXJ0aWNsZS51cGRhdGUoY2FudmFzLCB0aW1lLCBtb3VzZSk7XG4gICAgICAgIHBhcnRpY2xlLmRyYXcoY3R4KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyDQodC+0LXQtNC40L3Rj9C10Lwg0YfQsNGB0YLQuNGG0YtcbiAgICAgIGNvbm5lY3RQYXJ0aWNsZXModGltZSk7XG5cbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIH07XG5cbiAgICAvLyDQntCx0YDQsNCx0L7RgtGH0LjQutC4INGB0L7QsdGL0YLQuNC5XG4gICAgY29uc3QgaGFuZGxlTW91c2VNb3ZlID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgIG1vdXNlLnggPSBlLmNsaWVudFg7XG4gICAgICBtb3VzZS55ID0gZS5jbGllbnRZO1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZUxlYXZlID0gKCkgPT4ge1xuICAgICAgbW91c2UueCA9IG51bGw7XG4gICAgICBtb3VzZS55ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8g0JjQvdC40YbQuNCw0LvQuNC30LDRhtC40Y9cbiAgICBpbml0UGFydGljbGVzKCk7XG4gICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG5cbiAgICAvLyDQodC70YPRiNCw0YLQtdC70Lgg0YHQvtCx0YvRgtC40LlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemVDYW52YXMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGhhbmRsZU1vdXNlTGVhdmUpO1xuXG4gICAgLy8g0J7Rh9C40YHRgtC60LBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uUmVmLmN1cnJlbnQpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplQ2FudmFzKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgaGFuZGxlTW91c2VMZWF2ZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPGNhbnZhc1xuICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICBjbGFzc05hbWU9XCJhbmltYXRlZC1iYWNrZ3JvdW5kLWNhbnZhc1wiXG4gICAgICBzdHlsZT17e1xuICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgekluZGV4OiAtMTAsIC8vINCj0LLQtdC70LjRh9C40Lsg0L7RgtGA0LjRhtCw0YLQtdC70YzQvdGL0Lkgei1pbmRleFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgIH19XG4gICAgLz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGVkQmFja2dyb3VuZDtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsIkFuaW1hdGVkQmFja2dyb3VuZCIsImNhbnZhc1JlZiIsImFuaW1hdGlvblJlZiIsInRpbWVSZWYiLCJjYW52YXMiLCJjdXJyZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsInJlc2l6ZUNhbnZhcyIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImhlaWdodCIsImlubmVySGVpZ2h0IiwicGFydGljbGVzIiwibW91c2UiLCJ4IiwieSIsInJhZGl1cyIsImNlbnRlclgiLCJjZW50ZXJZIiwiUGFydGljbGUiLCJ1cGRhdGUiLCJ0aW1lIiwiaXNFbmVyZ3lQYXJ0aWNsZSIsIm9yYml0QW5nbGUiLCJvcmJpdFNwZWVkIiwicHVsc2UiLCJwdWxzZVNwZWVkIiwicHVsc2VFZmZlY3QiLCJNYXRoIiwic2luIiwiY3VycmVudE9yYml0UmFkaXVzIiwib3JiaXRSYWRpdXMiLCJjb3MiLCJhbHBoYSIsIndhdmVYIiwid2F2ZVNwZWVkIiwid2F2ZU9mZnNldCIsIndhdmVZIiwic3BlZWRYIiwic3BlZWRZIiwiZHgiLCJkeSIsImRpc3RhbmNlIiwic3FydCIsImF0dHJhY3Rpb25SYWRpdXMiLCJmb3JjZSIsIm14IiwibXkiLCJtb3VzZURpc3RhbmNlIiwibWluIiwic3BlZWQiLCJtYXhTcGVlZCIsImRyYXciLCJnbG9iYWxBbHBoYSIsImdyYWRpZW50IiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJzaXplIiwiYWRkQ29sb3JTdG9wIiwiZmlsbFN0eWxlIiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsIiwiY29sb3IiLCJzaGFkb3dDb2xvciIsInNoYWRvd0JsdXIiLCJjb25zdHJ1Y3RvciIsInJhbmRvbSIsImluaXRQYXJ0aWNsZXMiLCJwYXJ0aWNsZUNvdW50IiwiaSIsInB1c2giLCJkcmF3RHluYW1pY0dyYWRpZW50IiwibWF4IiwiZmlsbFJlY3QiLCJkcmF3TmV4dXMiLCJyb3RhdGlvbiIsInNhdmUiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJjb3JlR3JhZGllbnQiLCJyaW5nUmFkaXVzIiwicmluZ0FscGhhIiwicmluZ1B1bHNlIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJhbmdsZSIsImxlbmd0aCIsIm1vdmVUbyIsImxpbmVUbyIsInJlc3RvcmUiLCJjb25uZWN0UGFydGljbGVzIiwibWF4RGlzdGFuY2UiLCJkeFRvQ2VudGVyIiwiZHlUb0NlbnRlciIsImRpc3RhbmNlVG9DZW50ZXIiLCJvcGFjaXR5IiwiaiIsImlzRW5lcmd5Q29ubmVjdGlvbiIsImRyYXdHcmlkIiwiZ3JpZFNpemUiLCJncmlkT2Zmc2V0Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJhbmltYXRlIiwiZm9yRWFjaCIsInBhcnRpY2xlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaGFuZGxlTW91c2VNb3ZlIiwiZSIsImNsaWVudFgiLCJjbGllbnRZIiwiaGFuZGxlTW91c2VMZWF2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWYiLCJjbGFzc05hbWUiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsInpJbmRleCIsInBvaW50ZXJFdmVudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/animated-background.tsx\n"));

/***/ })

});