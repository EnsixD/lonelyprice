"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/cart/page",{

/***/ "(app-pages-browser)/./components/animated-background.tsx":
/*!********************************************!*\
  !*** ./components/animated-background.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnimatedBackground: function() { return /* binding */ AnimatedBackground; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ AnimatedBackground auto */ \nvar _s = $RefreshSig$();\n\nfunction AnimatedBackground() {\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (false) {}\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        const resizeCanvas = ()=>{\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n        };\n        resizeCanvas();\n        window.addEventListener(\"resize\", resizeCanvas);\n        const colors = {\n            background: \"#000000\",\n            darkest: \"#0a0a0a\",\n            dark: \"#1a1a1a\",\n            medium: \"#2a2a2a\",\n            light: \"#3a3a3a\",\n            lighter: \"#4a4a4a\",\n            lightest: \"#5a5a5a\",\n            white: \"#ffffff\",\n            offWhite: \"#f0f0f0\",\n            gray: \"#888888\",\n            accentLight: \"#e0e0e0\",\n            accentWhite: \"#ffffff\"\n        };\n        class Particle {\n            update(canvasWidth, canvasHeight) {\n                this.waveOffset += 0.04;\n                this.x += this.speedX + Math.sin(this.waveOffset * 1.5) * 0.3;\n                this.y += this.speedY + Math.cos(this.waveOffset) * 0.3;\n                this.size = this.originalSize + Math.sin(Date.now() * this.pulseSpeed) * 0.5;\n                if (this.x > canvasWidth + 20) this.x = -20;\n                if (this.x < -20) this.x = canvasWidth + 20;\n                if (this.y > canvasHeight + 20) this.y = -20;\n                if (this.y < -20) this.y = canvasHeight + 20;\n            }\n            draw(ctx) {\n                const glowSize = this.size * 4;\n                const glowGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);\n                if (this.color === colors.accentWhite) {\n                    glowGradient.addColorStop(0, \"rgba(255, 255, 255, 0.8)\");\n                    glowGradient.addColorStop(0.3, \"rgba(255, 255, 255, 0.2)\");\n                } else {\n                    glowGradient.addColorStop(0, \"\".concat(this.color).concat(Math.floor(this.opacity * 255).toString(16).padStart(2, \"0\")));\n                    glowGradient.addColorStop(0.5, \"\".concat(this.color).concat(Math.floor(this.opacity * 128).toString(16).padStart(2, \"0\")));\n                }\n                glowGradient.addColorStop(1, \"transparent\");\n                ctx.fillStyle = glowGradient;\n                ctx.beginPath();\n                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);\n                ctx.fill();\n                ctx.fillStyle = this.color;\n                ctx.globalAlpha = this.opacity;\n                ctx.beginPath();\n                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n                ctx.fill();\n                const innerGlowSize = this.size * 0.8;\n                const innerGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, innerGlowSize);\n                innerGradient.addColorStop(0, \"rgba(255, 255, 255, 0.9)\");\n                innerGradient.addColorStop(1, \"transparent\");\n                ctx.fillStyle = innerGradient;\n                ctx.beginPath();\n                ctx.arc(this.x, this.y, innerGlowSize, 0, Math.PI * 2);\n                ctx.fill();\n                ctx.globalAlpha = 1;\n            }\n            constructor(canvasWidth, canvasHeight){\n                this.x = Math.random() * canvasWidth;\n                this.y = Math.random() * canvasHeight;\n                this.originalSize = Math.random() * 1.5 + 0.5;\n                this.size = this.originalSize;\n                this.speedX = Math.random() * 0.6 - 0.3;\n                this.speedY = Math.random() * 0.6 - 0.3;\n                this.opacity = Math.random() * 0.6 + 0.1;\n                const rand = Math.random();\n                this.color = rand > 0.8 ? colors.accentWhite : rand > 0.6 ? colors.offWhite : rand > 0.4 ? colors.lightest : rand > 0.2 ? colors.lighter : colors.gray;\n                this.pulseSpeed = Math.random() * 0.03 + 0.01;\n                this.waveOffset = Math.random() * Math.PI * 2;\n            }\n        }\n        const particles = [];\n        const particleCount = 70;\n        for(let i = 0; i < particleCount; i++){\n            particles.push(new Particle(canvas.width, canvas.height));\n        }\n        let time = 0;\n        let wavePhase1 = 0;\n        let wavePhase2 = 0;\n        const createWaveGrid = ()=>{\n            const gridSize = 60;\n            const waveAmplitude = 15;\n            ctx.strokeStyle = \"rgba(255, 255, 255, 0.03)\";\n            ctx.lineWidth = 0.3;\n            for(let x = 0; x <= canvas.width; x += gridSize){\n                for(let y = 0; y <= canvas.height; y += gridSize){\n                    if (x < canvas.width) {\n                        ctx.beginPath();\n                        ctx.moveTo(x + Math.sin(y * 0.01 + time * 2 + wavePhase1) * waveAmplitude, y);\n                        ctx.lineTo(x + gridSize + Math.sin((y + gridSize) * 0.01 + time * 2 + wavePhase1) * waveAmplitude, y + gridSize);\n                        ctx.stroke();\n                    }\n                    if (y < canvas.height) {\n                        ctx.beginPath();\n                        ctx.moveTo(x, y + Math.cos(x * 0.01 + time * 1.5 + wavePhase2) * waveAmplitude);\n                        ctx.lineTo(x + gridSize, y + gridSize + Math.cos((x + gridSize) * 0.01 + time * 1.5 + wavePhase2) * waveAmplitude);\n                        ctx.stroke();\n                    }\n                }\n            }\n        };\n        const animate = ()=>{\n            ctx.fillStyle = \"rgba(0, 0, 0, 0.08)\";\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            time += 0.01;\n            wavePhase1 += 0.005;\n            wavePhase2 += 0.003;\n            const bgGradient1 = ctx.createRadialGradient(canvas.width * 0.5, canvas.height * 0.5, 0, canvas.width * 0.5, canvas.height * 0.5, Math.max(canvas.width, canvas.height) * 0.8);\n            bgGradient1.addColorStop(0, \"rgba(40, 40, 40, \".concat(0.05 + Math.sin(time) * 0.02, \")\"));\n            bgGradient1.addColorStop(0.5, \"rgba(20, 20, 20, \".concat(0.03 + Math.cos(time * 1.3) * 0.01, \")\"));\n            bgGradient1.addColorStop(1, \"rgba(0, 0, 0, \".concat(0.01, \")\"));\n            ctx.fillStyle = bgGradient1;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            createWaveGrid();\n            ctx.lineWidth = 0.5;\n            for(let i = 0; i < 3; i++){\n                const amplitude = 30 + i * 15;\n                const frequency = 0.005 + i * 0.002;\n                const speed = 0.5 + i * 0.2;\n                ctx.beginPath();\n                ctx.strokeStyle = \"rgba(255, 255, 255, \".concat(0.02 - i * 0.005, \")\");\n                for(let x = 0; x < canvas.width; x += 2){\n                    const y = canvas.height * (0.3 + i * 0.2) + Math.sin(x * frequency + time * speed + i * Math.PI / 2) * amplitude;\n                    if (x === 0) {\n                        ctx.moveTo(x, y);\n                    } else {\n                        ctx.lineTo(x, y);\n                    }\n                }\n                ctx.stroke();\n            }\n            particles.forEach((particle)=>{\n                particle.update(canvas.width, canvas.height);\n                particle.draw(ctx);\n            });\n            ctx.lineWidth = 0.3;\n            particles.forEach((particleA, indexA)=>{\n                particles.slice(indexA + 1).forEach((particleB)=>{\n                    const dx = particleA.x - particleB.x;\n                    const dy = particleA.y - particleB.y;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    if (distance < 120) {\n                        const opacity = 0.2 * (1 - distance / 120) * Math.min(particleA.opacity, particleB.opacity) * (0.7 + Math.sin(time * 2) * 0.3);\n                        const lineGradient = ctx.createLinearGradient(particleA.x, particleA.y, particleB.x, particleB.y);\n                        lineGradient.addColorStop(0, \"rgba(255, 255, 255, \".concat(opacity, \")\"));\n                        lineGradient.addColorStop(0.5, \"rgba(200, 200, 200, \".concat(opacity * 0.7, \")\"));\n                        lineGradient.addColorStop(1, \"rgba(150, 150, 150, \".concat(opacity * 0.4, \")\"));\n                        ctx.strokeStyle = lineGradient;\n                        ctx.beginPath();\n                        ctx.moveTo(particleA.x, particleA.y);\n                        const controlX = (particleA.x + particleB.x) / 2 + Math.sin(time * 3 + distance * 0.01) * 20;\n                        const controlY = (particleA.y + particleB.y) / 2 + Math.cos(time * 2 + distance * 0.01) * 20;\n                        ctx.quadraticCurveTo(controlX, controlY, particleB.x, particleB.y);\n                        ctx.stroke();\n                    }\n                });\n            });\n            const scanLineHeight = 1;\n            const scanPosition = Date.now() * 0.1 % (canvas.height + 100);\n            const scanGradient = ctx.createLinearGradient(0, 0, 0, scanLineHeight * 2);\n            scanGradient.addColorStop(0, \"rgba(255, 255, 255, 0)\");\n            scanGradient.addColorStop(0.3, \"rgba(255, 255, 255, 0.3)\");\n            scanGradient.addColorStop(0.7, \"rgba(255, 255, 255, 0.3)\");\n            scanGradient.addColorStop(1, \"rgba(255, 255, 255, 0)\");\n            ctx.fillStyle = scanGradient;\n            ctx.fillRect(0, scanPosition - scanLineHeight, canvas.width, scanLineHeight * 2);\n            const pulseSize = 50 + Math.sin(time * 2) * 20;\n            const cornerCircles = [\n                {\n                    x: 0,\n                    y: 0\n                },\n                {\n                    x: canvas.width,\n                    y: 0\n                },\n                {\n                    x: 0,\n                    y: canvas.height\n                },\n                {\n                    x: canvas.width,\n                    y: canvas.height\n                }\n            ];\n            cornerCircles.forEach((corner, i)=>{\n                const pulseOpacity = 0.03 + Math.sin(time * 3 + i) * 0.02;\n                const pulseGradient = ctx.createRadialGradient(corner.x, corner.y, 0, corner.x, corner.y, pulseSize);\n                pulseGradient.addColorStop(0, \"rgba(255, 255, 255, \".concat(pulseOpacity, \")\"));\n                pulseGradient.addColorStop(1, \"transparent\");\n                ctx.fillStyle = pulseGradient;\n                ctx.beginPath();\n                ctx.arc(corner.x, corner.y, pulseSize, 0, Math.PI * 2);\n                ctx.fill();\n            });\n            animationRef.current = requestAnimationFrame(animate);\n        };\n        animate();\n        return ()=>{\n            window.removeEventListener(\"resize\", resizeCanvas);\n            if (animationRef.current) {\n                cancelAnimationFrame(animationRef.current);\n            }\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                className: \"fixed top-0 left-0 w-full h-full -z-10\",\n                style: {\n                    background: \"linear-gradient(135deg, #000000 0%, #0a0a0a 50%, #000000 100%)\"\n                }\n            }, void 0, false, {\n                fileName: \"/home/ensi/Projects/lonlyprice/components/animated-background.tsx\",\n                lineNumber: 376,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"fixed top-0 left-0 w-full h-full -z-10 pointer-events-none\",\n                style: {\n                    background: \"\\n            radial-gradient(ellipse at 10% 20%, rgba(255, 255, 255, 0.02) 0%, transparent 50%),\\n            radial-gradient(ellipse at 90% 80%, rgba(255, 255, 255, 0.015) 0%, transparent 50%),\\n            radial-gradient(ellipse at 50% 50%, rgba(255, 255, 255, 0.01) 0%, transparent 60%)\\n          \",\n                    backdropFilter: \"blur(60px) contrast(120%)\",\n                    mixBlendMode: \"overlay\"\n                }\n            }, void 0, false, {\n                fileName: \"/home/ensi/Projects/lonlyprice/components/animated-background.tsx\",\n                lineNumber: 384,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"fixed top-0 left-0 w-full h-full -z-10 pointer-events-none\",\n                style: {\n                    background: \"radial-gradient(ellipse at center, transparent 30%, rgba(0, 0, 0, 0.9) 70%)\"\n                }\n            }, void 0, false, {\n                fileName: \"/home/ensi/Projects/lonlyprice/components/animated-background.tsx\",\n                lineNumber: 396,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(AnimatedBackground, \"X5bd7Q1XXg1keIMflMhOltk4wyU=\");\n_c = AnimatedBackground;\nvar _c;\n$RefreshReg$(_c, \"AnimatedBackground\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvYW5pbWF0ZWQtYmFja2dyb3VuZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRTBDO0FBRW5DLFNBQVNFOztJQUNkLE1BQU1DLFlBQVlGLDZDQUFNQSxDQUFvQjtJQUM1QyxNQUFNRyxlQUFlSCw2Q0FBTUE7SUFFM0JELGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxLQUE2QixFQUFFLEVBQU87UUFFMUMsTUFBTUssU0FBU0YsVUFBVUcsT0FBTztRQUNoQyxJQUFJLENBQUNELFFBQVE7UUFFYixNQUFNRSxNQUFNRixPQUFPRyxVQUFVLENBQUM7UUFDOUIsSUFBSSxDQUFDRCxLQUFLO1FBRVYsTUFBTUUsZUFBZTtZQUNuQkosT0FBT0ssS0FBSyxHQUFHQyxPQUFPQyxVQUFVO1lBQ2hDUCxPQUFPUSxNQUFNLEdBQUdGLE9BQU9HLFdBQVc7UUFDcEM7UUFFQUw7UUFDQUUsT0FBT0ksZ0JBQWdCLENBQUMsVUFBVU47UUFFbEMsTUFBTU8sU0FBUztZQUNiQyxZQUFZO1lBQ1pDLFNBQVM7WUFDVEMsTUFBTTtZQUNOQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsU0FBUztZQUNUQyxVQUFVO1lBQ1ZDLE9BQU87WUFDUEMsVUFBVTtZQUNWQyxNQUFNO1lBQ05DLGFBQWE7WUFDYkMsYUFBYTtRQUNmO1FBRUEsTUFBTUM7WUFtQ0pDLE9BQU9DLFdBQW1CLEVBQUVDLFlBQW9CLEVBQUU7Z0JBQ2hELElBQUksQ0FBQ0MsVUFBVSxJQUFJO2dCQUNuQixJQUFJLENBQUNDLENBQUMsSUFBSSxJQUFJLENBQUNDLE1BQU0sR0FBR0MsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQ0osVUFBVSxHQUFHLE9BQU87Z0JBQzFELElBQUksQ0FBQ0ssQ0FBQyxJQUFJLElBQUksQ0FBQ0MsTUFBTSxHQUFHSCxLQUFLSSxHQUFHLENBQUMsSUFBSSxDQUFDUCxVQUFVLElBQUk7Z0JBQ3BELElBQUksQ0FBQ1EsSUFBSSxHQUNQLElBQUksQ0FBQ0Ms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QSxPQUFPO1lBQ0x2RSxPQUFPdUcsbUJBQW1CLENBQUMsVUFBVXpHO1lBQ3JDLElBQUlMLGFBQWFFLE9BQU8sRUFBRTtnQkFDeEI2RyxxQkFBcUIvRyxhQUFhRSxPQUFPO1lBQzNDO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFFTCxxQkFDRTs7MEJBQ0UsOERBQUNEO2dCQUNDK0csS0FBS2pIO2dCQUNMa0gsV0FBVTtnQkFDVkMsT0FBTztvQkFDTHJHLFlBQ0U7Z0JBQ0o7Ozs7OzswQkFFRiw4REFBQ3NHO2dCQUNDRixXQUFVO2dCQUNWQyxPQUFPO29CQUNMckcsWUFBYTtvQkFLYnVHLGdCQUFnQjtvQkFDaEJDLGNBQWM7Z0JBQ2hCOzs7Ozs7MEJBRUYsOERBQUNGO2dCQUNDRixXQUFVO2dCQUNWQyxPQUFPO29CQUNMckcsWUFDRTtnQkFDSjs7Ozs7Ozs7QUFJUjtHQWhaZ0JmO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvYW5pbWF0ZWQtYmFja2dyb3VuZC50c3g/M2Q0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIEFuaW1hdGVkQmFja2dyb3VuZCgpIHtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50PihudWxsKTtcbiAgY29uc3QgYW5pbWF0aW9uUmVmID0gdXNlUmVmPG51bWJlcj4oKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG5cbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xuXG4gICAgY29uc3QgcmVzaXplQ2FudmFzID0gKCkgPT4ge1xuICAgICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIH07XG5cbiAgICByZXNpemVDYW52YXMoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemVDYW52YXMpO1xuXG4gICAgY29uc3QgY29sb3JzID0ge1xuICAgICAgYmFja2dyb3VuZDogXCIjMDAwMDAwXCIsXG4gICAgICBkYXJrZXN0OiBcIiMwYTBhMGFcIixcbiAgICAgIGRhcms6IFwiIzFhMWExYVwiLFxuICAgICAgbWVkaXVtOiBcIiMyYTJhMmFcIixcbiAgICAgIGxpZ2h0OiBcIiMzYTNhM2FcIixcbiAgICAgIGxpZ2h0ZXI6IFwiIzRhNGE0YVwiLFxuICAgICAgbGlnaHRlc3Q6IFwiIzVhNWE1YVwiLFxuICAgICAgd2hpdGU6IFwiI2ZmZmZmZlwiLFxuICAgICAgb2ZmV2hpdGU6IFwiI2YwZjBmMFwiLFxuICAgICAgZ3JheTogXCIjODg4ODg4XCIsXG4gICAgICBhY2NlbnRMaWdodDogXCIjZTBlMGUwXCIsXG4gICAgICBhY2NlbnRXaGl0ZTogXCIjZmZmZmZmXCIsXG4gICAgfTtcblxuICAgIGNsYXNzIFBhcnRpY2xlIHtcbiAgICAgIHg6IG51bWJlcjtcbiAgICAgIHk6IG51bWJlcjtcbiAgICAgIHNpemU6IG51bWJlcjtcbiAgICAgIHNwZWVkWDogbnVtYmVyO1xuICAgICAgc3BlZWRZOiBudW1iZXI7XG4gICAgICBvcGFjaXR5OiBudW1iZXI7XG4gICAgICBjb2xvcjogc3RyaW5nO1xuICAgICAgcHVsc2VTcGVlZDogbnVtYmVyO1xuICAgICAgd2F2ZU9mZnNldDogbnVtYmVyO1xuICAgICAgb3JpZ2luYWxTaXplOiBudW1iZXI7XG5cbiAgICAgIGNvbnN0cnVjdG9yKGNhbnZhc1dpZHRoOiBudW1iZXIsIGNhbnZhc0hlaWdodDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMueCA9IE1hdGgucmFuZG9tKCkgKiBjYW52YXNXaWR0aDtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5yYW5kb20oKSAqIGNhbnZhc0hlaWdodDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFNpemUgPSBNYXRoLnJhbmRvbSgpICogMS41ICsgMC41O1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLm9yaWdpbmFsU2l6ZTtcbiAgICAgICAgdGhpcy5zcGVlZFggPSBNYXRoLnJhbmRvbSgpICogMC42IC0gMC4zO1xuICAgICAgICB0aGlzLnNwZWVkWSA9IE1hdGgucmFuZG9tKCkgKiAwLjYgLSAwLjM7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IE1hdGgucmFuZG9tKCkgKiAwLjYgKyAwLjE7XG4gICAgICAgIGNvbnN0IHJhbmQgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB0aGlzLmNvbG9yID1cbiAgICAgICAgICByYW5kID4gMC44XG4gICAgICAgICAgICA/IGNvbG9ycy5hY2NlbnRXaGl0ZVxuICAgICAgICAgICAgOiByYW5kID4gMC42XG4gICAgICAgICAgICA/IGNvbG9ycy5vZmZXaGl0ZVxuICAgICAgICAgICAgOiByYW5kID4gMC40XG4gICAgICAgICAgICA/IGNvbG9ycy5saWdodGVzdFxuICAgICAgICAgICAgOiByYW5kID4gMC4yXG4gICAgICAgICAgICA/IGNvbG9ycy5saWdodGVyXG4gICAgICAgICAgICA6IGNvbG9ycy5ncmF5O1xuICAgICAgICB0aGlzLnB1bHNlU3BlZWQgPSBNYXRoLnJhbmRvbSgpICogMC4wMyArIDAuMDE7XG4gICAgICAgIHRoaXMud2F2ZU9mZnNldCA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKGNhbnZhc1dpZHRoOiBudW1iZXIsIGNhbnZhc0hlaWdodDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMud2F2ZU9mZnNldCArPSAwLjA0O1xuICAgICAgICB0aGlzLnggKz0gdGhpcy5zcGVlZFggKyBNYXRoLnNpbih0aGlzLndhdmVPZmZzZXQgKiAxLjUpICogMC4zO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy5zcGVlZFkgKyBNYXRoLmNvcyh0aGlzLndhdmVPZmZzZXQpICogMC4zO1xuICAgICAgICB0aGlzLnNpemUgPVxuICAgICAgICAgIHRoaXMub3JpZ2luYWxTaXplICsgTWF0aC5zaW4oRGF0ZS5ub3coKSAqIHRoaXMucHVsc2VTcGVlZCkgKiAwLjU7XG5cbiAgICAgICAgaWYgKHRoaXMueCA+IGNhbnZhc1dpZHRoICsgMjApIHRoaXMueCA9IC0yMDtcbiAgICAgICAgaWYgKHRoaXMueCA8IC0yMCkgdGhpcy54ID0gY2FudmFzV2lkdGggKyAyMDtcbiAgICAgICAgaWYgKHRoaXMueSA+IGNhbnZhc0hlaWdodCArIDIwKSB0aGlzLnkgPSAtMjA7XG4gICAgICAgIGlmICh0aGlzLnkgPCAtMjApIHRoaXMueSA9IGNhbnZhc0hlaWdodCArIDIwO1xuICAgICAgfVxuXG4gICAgICBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgICAgIGNvbnN0IGdsb3dTaXplID0gdGhpcy5zaXplICogNDtcbiAgICAgICAgY29uc3QgZ2xvd0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgICAgIHRoaXMueCxcbiAgICAgICAgICB0aGlzLnksXG4gICAgICAgICAgMCxcbiAgICAgICAgICB0aGlzLngsXG4gICAgICAgICAgdGhpcy55LFxuICAgICAgICAgIGdsb3dTaXplXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29sb3IgPT09IGNvbG9ycy5hY2NlbnRXaGl0ZSkge1xuICAgICAgICAgIGdsb3dHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOClcIik7XG4gICAgICAgICAgZ2xvd0dyYWRpZW50LmFkZENvbG9yU3RvcCgwLjMsIFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsb3dHcmFkaWVudC5hZGRDb2xvclN0b3AoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgYCR7dGhpcy5jb2xvcn0ke01hdGguZmxvb3IodGhpcy5vcGFjaXR5ICogMjU1KVxuICAgICAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgIC5wYWRTdGFydCgyLCBcIjBcIil9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgZ2xvd0dyYWRpZW50LmFkZENvbG9yU3RvcChcbiAgICAgICAgICAgIDAuNSxcbiAgICAgICAgICAgIGAke3RoaXMuY29sb3J9JHtNYXRoLmZsb29yKHRoaXMub3BhY2l0eSAqIDEyOClcbiAgICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAucGFkU3RhcnQoMiwgXCIwXCIpfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGdsb3dHcmFkaWVudC5hZGRDb2xvclN0b3AoMSwgXCJ0cmFuc3BhcmVudFwiKTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZ2xvd0dyYWRpZW50O1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5hcmModGhpcy54LCB0aGlzLnksIGdsb3dTaXplLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnNpemUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICBjb25zdCBpbm5lckdsb3dTaXplID0gdGhpcy5zaXplICogMC44O1xuICAgICAgICBjb25zdCBpbm5lckdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgICAgIHRoaXMueCxcbiAgICAgICAgICB0aGlzLnksXG4gICAgICAgICAgMCxcbiAgICAgICAgICB0aGlzLngsXG4gICAgICAgICAgdGhpcy55LFxuICAgICAgICAgIGlubmVyR2xvd1NpemVcbiAgICAgICAgKTtcbiAgICAgICAgaW5uZXJHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSlcIik7XG4gICAgICAgIGlubmVyR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFwidHJhbnNwYXJlbnRcIik7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGlubmVyR3JhZGllbnQ7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyh0aGlzLngsIHRoaXMueSwgaW5uZXJHbG93U2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICBjdHguZmlsbCgpO1xuXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGFydGljbGVzOiBQYXJ0aWNsZVtdID0gW107XG4gICAgY29uc3QgcGFydGljbGVDb3VudCA9IDcwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGljbGVDb3VudDsgaSsrKSB7XG4gICAgICBwYXJ0aWNsZXMucHVzaChuZXcgUGFydGljbGUoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KSk7XG4gICAgfVxuXG4gICAgbGV0IHRpbWUgPSAwO1xuICAgIGxldCB3YXZlUGhhc2UxID0gMDtcbiAgICBsZXQgd2F2ZVBoYXNlMiA9IDA7XG5cbiAgICBjb25zdCBjcmVhdGVXYXZlR3JpZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGdyaWRTaXplID0gNjA7XG4gICAgICBjb25zdCB3YXZlQW1wbGl0dWRlID0gMTU7XG5cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDMpYDtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAwLjM7XG5cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDw9IGNhbnZhcy53aWR0aDsgeCArPSBncmlkU2l6ZSkge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8PSBjYW52YXMuaGVpZ2h0OyB5ICs9IGdyaWRTaXplKSB7XG4gICAgICAgICAgaWYgKHggPCBjYW52YXMud2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oXG4gICAgICAgICAgICAgIHggKyBNYXRoLnNpbih5ICogMC4wMSArIHRpbWUgKiAyICsgd2F2ZVBoYXNlMSkgKiB3YXZlQW1wbGl0dWRlLFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgeCArXG4gICAgICAgICAgICAgICAgZ3JpZFNpemUgK1xuICAgICAgICAgICAgICAgIE1hdGguc2luKCh5ICsgZ3JpZFNpemUpICogMC4wMSArIHRpbWUgKiAyICsgd2F2ZVBoYXNlMSkgKlxuICAgICAgICAgICAgICAgICAgd2F2ZUFtcGxpdHVkZSxcbiAgICAgICAgICAgICAgeSArIGdyaWRTaXplXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh5IDwgY2FudmFzLmhlaWdodCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeSArIE1hdGguY29zKHggKiAwLjAxICsgdGltZSAqIDEuNSArIHdhdmVQaGFzZTIpICogd2F2ZUFtcGxpdHVkZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oXG4gICAgICAgICAgICAgIHggKyBncmlkU2l6ZSxcbiAgICAgICAgICAgICAgeSArXG4gICAgICAgICAgICAgICAgZ3JpZFNpemUgK1xuICAgICAgICAgICAgICAgIE1hdGguY29zKCh4ICsgZ3JpZFNpemUpICogMC4wMSArIHRpbWUgKiAxLjUgKyB3YXZlUGhhc2UyKSAqXG4gICAgICAgICAgICAgICAgICB3YXZlQW1wbGl0dWRlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLCAwLCAwLCAwLjA4KVwiO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgIHRpbWUgKz0gMC4wMTtcbiAgICAgIHdhdmVQaGFzZTEgKz0gMC4wMDU7XG4gICAgICB3YXZlUGhhc2UyICs9IDAuMDAzO1xuXG4gICAgICBjb25zdCBiZ0dyYWRpZW50MSA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgICAgY2FudmFzLndpZHRoICogMC41LFxuICAgICAgICBjYW52YXMuaGVpZ2h0ICogMC41LFxuICAgICAgICAwLFxuICAgICAgICBjYW52YXMud2lkdGggKiAwLjUsXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgKiAwLjUsXG4gICAgICAgIE1hdGgubWF4KGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCkgKiAwLjhcbiAgICAgICk7XG5cbiAgICAgIGJnR3JhZGllbnQxLmFkZENvbG9yU3RvcChcbiAgICAgICAgMCxcbiAgICAgICAgYHJnYmEoNDAsIDQwLCA0MCwgJHswLjA1ICsgTWF0aC5zaW4odGltZSkgKiAwLjAyfSlgXG4gICAgICApO1xuICAgICAgYmdHcmFkaWVudDEuYWRkQ29sb3JTdG9wKFxuICAgICAgICAwLjUsXG4gICAgICAgIGByZ2JhKDIwLCAyMCwgMjAsICR7MC4wMyArIE1hdGguY29zKHRpbWUgKiAxLjMpICogMC4wMX0pYFxuICAgICAgKTtcbiAgICAgIGJnR3JhZGllbnQxLmFkZENvbG9yU3RvcCgxLCBgcmdiYSgwLCAwLCAwLCAkezAuMDF9KWApO1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gYmdHcmFkaWVudDE7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgY3JlYXRlV2F2ZUdyaWQoKTtcblxuICAgICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFtcGxpdHVkZSA9IDMwICsgaSAqIDE1O1xuICAgICAgICBjb25zdCBmcmVxdWVuY3kgPSAwLjAwNSArIGkgKiAwLjAwMjtcbiAgICAgICAgY29uc3Qgc3BlZWQgPSAwLjUgKyBpICogMC4yO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYHJnYmEoMjU1LCAyNTUsIDI1NSwgJHswLjAyIC0gaSAqIDAuMDA1fSlgO1xuXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4ICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB5ID1cbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgKiAoMC4zICsgaSAqIDAuMikgK1xuICAgICAgICAgICAgTWF0aC5zaW4oeCAqIGZyZXF1ZW5jeSArIHRpbWUgKiBzcGVlZCArIChpICogTWF0aC5QSSkgLyAyKSAqXG4gICAgICAgICAgICAgIGFtcGxpdHVkZTtcblxuICAgICAgICAgIGlmICh4ID09PSAwKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIHBhcnRpY2xlcy5mb3JFYWNoKChwYXJ0aWNsZSkgPT4ge1xuICAgICAgICBwYXJ0aWNsZS51cGRhdGUoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgcGFydGljbGUuZHJhdyhjdHgpO1xuICAgICAgfSk7XG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSAwLjM7XG4gICAgICBwYXJ0aWNsZXMuZm9yRWFjaCgocGFydGljbGVBLCBpbmRleEEpID0+IHtcbiAgICAgICAgcGFydGljbGVzLnNsaWNlKGluZGV4QSArIDEpLmZvckVhY2goKHBhcnRpY2xlQikgPT4ge1xuICAgICAgICAgIGNvbnN0IGR4ID0gcGFydGljbGVBLnggLSBwYXJ0aWNsZUIueDtcbiAgICAgICAgICBjb25zdCBkeSA9IHBhcnRpY2xlQS55IC0gcGFydGljbGVCLnk7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlIDwgMTIwKSB7XG4gICAgICAgICAgICBjb25zdCBvcGFjaXR5ID1cbiAgICAgICAgICAgICAgMC4yICpcbiAgICAgICAgICAgICAgKDEgLSBkaXN0YW5jZSAvIDEyMCkgKlxuICAgICAgICAgICAgICBNYXRoLm1pbihwYXJ0aWNsZUEub3BhY2l0eSwgcGFydGljbGVCLm9wYWNpdHkpICpcbiAgICAgICAgICAgICAgKDAuNyArIE1hdGguc2luKHRpbWUgKiAyKSAqIDAuMyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGxpbmVHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChcbiAgICAgICAgICAgICAgcGFydGljbGVBLngsXG4gICAgICAgICAgICAgIHBhcnRpY2xlQS55LFxuICAgICAgICAgICAgICBwYXJ0aWNsZUIueCxcbiAgICAgICAgICAgICAgcGFydGljbGVCLnlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxpbmVHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgYHJnYmEoMjU1LCAyNTUsIDI1NSwgJHtvcGFjaXR5fSlgKTtcbiAgICAgICAgICAgIGxpbmVHcmFkaWVudC5hZGRDb2xvclN0b3AoXG4gICAgICAgICAgICAgIDAuNSxcbiAgICAgICAgICAgICAgYHJnYmEoMjAwLCAyMDAsIDIwMCwgJHtvcGFjaXR5ICogMC43fSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGluZUdyYWRpZW50LmFkZENvbG9yU3RvcChcbiAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgYHJnYmEoMTUwLCAxNTAsIDE1MCwgJHtvcGFjaXR5ICogMC40fSlgXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsaW5lR3JhZGllbnQ7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHBhcnRpY2xlQS54LCBwYXJ0aWNsZUEueSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xYID1cbiAgICAgICAgICAgICAgKHBhcnRpY2xlQS54ICsgcGFydGljbGVCLngpIC8gMiArXG4gICAgICAgICAgICAgIE1hdGguc2luKHRpbWUgKiAzICsgZGlzdGFuY2UgKiAwLjAxKSAqIDIwO1xuICAgICAgICAgICAgY29uc3QgY29udHJvbFkgPVxuICAgICAgICAgICAgICAocGFydGljbGVBLnkgKyBwYXJ0aWNsZUIueSkgLyAyICtcbiAgICAgICAgICAgICAgTWF0aC5jb3ModGltZSAqIDIgKyBkaXN0YW5jZSAqIDAuMDEpICogMjA7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjb250cm9sWCwgY29udHJvbFksIHBhcnRpY2xlQi54LCBwYXJ0aWNsZUIueSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzY2FuTGluZUhlaWdodCA9IDE7XG4gICAgICBjb25zdCBzY2FuUG9zaXRpb24gPSAoRGF0ZS5ub3coKSAqIDAuMSkgJSAoY2FudmFzLmhlaWdodCArIDEwMCk7XG4gICAgICBjb25zdCBzY2FuR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIHNjYW5MaW5lSGVpZ2h0ICogMlxuICAgICAgKTtcbiAgICAgIHNjYW5HcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDApXCIpO1xuICAgICAgc2NhbkdyYWRpZW50LmFkZENvbG9yU3RvcCgwLjMsIFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpXCIpO1xuICAgICAgc2NhbkdyYWRpZW50LmFkZENvbG9yU3RvcCgwLjcsIFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpXCIpO1xuICAgICAgc2NhbkdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMClcIik7XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBzY2FuR3JhZGllbnQ7XG4gICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgIDAsXG4gICAgICAgIHNjYW5Qb3NpdGlvbiAtIHNjYW5MaW5lSGVpZ2h0LFxuICAgICAgICBjYW52YXMud2lkdGgsXG4gICAgICAgIHNjYW5MaW5lSGVpZ2h0ICogMlxuICAgICAgKTtcblxuICAgICAgY29uc3QgcHVsc2VTaXplID0gNTAgKyBNYXRoLnNpbih0aW1lICogMikgKiAyMDtcbiAgICAgIGNvbnN0IGNvcm5lckNpcmNsZXMgPSBbXG4gICAgICAgIHsgeDogMCwgeTogMCB9LFxuICAgICAgICB7IHg6IGNhbnZhcy53aWR0aCwgeTogMCB9LFxuICAgICAgICB7IHg6IDAsIHk6IGNhbnZhcy5oZWlnaHQgfSxcbiAgICAgICAgeyB4OiBjYW52YXMud2lkdGgsIHk6IGNhbnZhcy5oZWlnaHQgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvcm5lckNpcmNsZXMuZm9yRWFjaCgoY29ybmVyLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHB1bHNlT3BhY2l0eSA9IDAuMDMgKyBNYXRoLnNpbih0aW1lICogMyArIGkpICogMC4wMjtcbiAgICAgICAgY29uc3QgcHVsc2VHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgICAgICBjb3JuZXIueCxcbiAgICAgICAgICBjb3JuZXIueSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGNvcm5lci54LFxuICAgICAgICAgIGNvcm5lci55LFxuICAgICAgICAgIHB1bHNlU2l6ZVxuICAgICAgICApO1xuICAgICAgICBwdWxzZUdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBgcmdiYSgyNTUsIDI1NSwgMjU1LCAke3B1bHNlT3BhY2l0eX0pYCk7XG4gICAgICAgIHB1bHNlR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFwidHJhbnNwYXJlbnRcIik7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHB1bHNlR3JhZGllbnQ7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyhjb3JuZXIueCwgY29ybmVyLnksIHB1bHNlU2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIH07XG5cbiAgICBhbmltYXRlKCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplQ2FudmFzKTtcbiAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25SZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxjYW52YXNcbiAgICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICAgIGNsYXNzTmFtZT1cImZpeGVkIHRvcC0wIGxlZnQtMCB3LWZ1bGwgaC1mdWxsIC16LTEwXCJcbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBiYWNrZ3JvdW5kOlxuICAgICAgICAgICAgXCJsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjMDAwMDAwIDAlLCAjMGEwYTBhIDUwJSwgIzAwMDAwMCAxMDAlKVwiLFxuICAgICAgICB9fVxuICAgICAgLz5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPVwiZml4ZWQgdG9wLTAgbGVmdC0wIHctZnVsbCBoLWZ1bGwgLXotMTAgcG9pbnRlci1ldmVudHMtbm9uZVwiXG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgYmFja2dyb3VuZDogYFxuICAgICAgICAgICAgcmFkaWFsLWdyYWRpZW50KGVsbGlwc2UgYXQgMTAlIDIwJSwgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjAyKSAwJSwgdHJhbnNwYXJlbnQgNTAlKSxcbiAgICAgICAgICAgIHJhZGlhbC1ncmFkaWVudChlbGxpcHNlIGF0IDkwJSA4MCUsIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wMTUpIDAlLCB0cmFuc3BhcmVudCA1MCUpLFxuICAgICAgICAgICAgcmFkaWFsLWdyYWRpZW50KGVsbGlwc2UgYXQgNTAlIDUwJSwgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjAxKSAwJSwgdHJhbnNwYXJlbnQgNjAlKVxuICAgICAgICAgIGAsXG4gICAgICAgICAgYmFja2Ryb3BGaWx0ZXI6IFwiYmx1cig2MHB4KSBjb250cmFzdCgxMjAlKVwiLFxuICAgICAgICAgIG1peEJsZW5kTW9kZTogXCJvdmVybGF5XCIsXG4gICAgICAgIH19XG4gICAgICAvPlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9XCJmaXhlZCB0b3AtMCBsZWZ0LTAgdy1mdWxsIGgtZnVsbCAtei0xMCBwb2ludGVyLWV2ZW50cy1ub25lXCJcbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBiYWNrZ3JvdW5kOlxuICAgICAgICAgICAgXCJyYWRpYWwtZ3JhZGllbnQoZWxsaXBzZSBhdCBjZW50ZXIsIHRyYW5zcGFyZW50IDMwJSwgcmdiYSgwLCAwLCAwLCAwLjkpIDcwJSlcIixcbiAgICAgICAgfX1cbiAgICAgIC8+XG4gICAgPC8+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiQW5pbWF0ZWRCYWNrZ3JvdW5kIiwiY2FudmFzUmVmIiwiYW5pbWF0aW9uUmVmIiwiY2FudmFzIiwiY3VycmVudCIsImN0eCIsImdldENvbnRleHQiLCJyZXNpemVDYW52YXMiLCJ3aWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJoZWlnaHQiLCJpbm5lckhlaWdodCIsImFkZEV2ZW50TGlzdGVuZXIiLCJjb2xvcnMiLCJiYWNrZ3JvdW5kIiwiZGFya2VzdCIsImRhcmsiLCJtZWRpdW0iLCJsaWdodCIsImxpZ2h0ZXIiLCJsaWdodGVzdCIsIndoaXRlIiwib2ZmV2hpdGUiLCJncmF5IiwiYWNjZW50TGlnaHQiLCJhY2NlbnRXaGl0ZSIsIlBhcnRpY2xlIiwidXBkYXRlIiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJ3YXZlT2Zmc2V0IiwieCIsInNwZWVkWCIsIk1hdGgiLCJzaW4iLCJ5Iiwic3BlZWRZIiwiY29zIiwic2l6ZSIsIm9yaWdpbmFsU2l6ZSIsIkRhdGUiLCJub3ciLCJwdWxzZVNwZWVkIiwiZHJhdyIsImdsb3dTaXplIiwiZ2xvd0dyYWRpZW50IiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJjb2xvciIsImFkZENvbG9yU3RvcCIsImZsb29yIiwib3BhY2l0eSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJmaWxsU3R5bGUiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGwiLCJnbG9iYWxBbHBoYSIsImlubmVyR2xvd1NpemUiLCJpbm5lckdyYWRpZW50IiwiY29uc3RydWN0b3IiLCJyYW5kb20iLCJyYW5kIiwicGFydGljbGVzIiwicGFydGljbGVDb3VudCIsImkiLCJwdXNoIiwidGltZSIsIndhdmVQaGFzZTEiLCJ3YXZlUGhhc2UyIiwiY3JlYXRlV2F2ZUdyaWQiLCJncmlkU2l6ZSIsIndhdmVBbXBsaXR1ZGUiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsImFuaW1hdGUiLCJmaWxsUmVjdCIsImJnR3JhZGllbnQxIiwibWF4IiwiYW1wbGl0dWRlIiwiZnJlcXVlbmN5Iiwic3BlZWQiLCJmb3JFYWNoIiwicGFydGljbGUiLCJwYXJ0aWNsZUEiLCJpbmRleEEiLCJzbGljZSIsInBhcnRpY2xlQiIsImR4IiwiZHkiLCJkaXN0YW5jZSIsInNxcnQiLCJtaW4iLCJsaW5lR3JhZGllbnQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImNvbnRyb2xYIiwiY29udHJvbFkiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwic2NhbkxpbmVIZWlnaHQiLCJzY2FuUG9zaXRpb24iLCJzY2FuR3JhZGllbnQiLCJwdWxzZVNpemUiLCJjb3JuZXJDaXJjbGVzIiwiY29ybmVyIiwicHVsc2VPcGFjaXR5IiwicHVsc2VHcmFkaWVudCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlZiIsImNsYXNzTmFtZSIsInN0eWxlIiwiZGl2IiwiYmFja2Ryb3BGaWx0ZXIiLCJtaXhCbGVuZE1vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/animated-background.tsx\n"));

/***/ })

});